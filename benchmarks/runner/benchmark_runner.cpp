#include <benchmark/benchmark.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>
#include <chrono>
#include <map>

struct BenchmarkResult {
    std::string name;
    std::string t81_result_str;
    std::string binary_result_str;
    double t81_result_val = 0.0;
    double binary_result_val = 0.0;
    std::string t81_advantage;
    std::string notes;
};

std::map<std::string, BenchmarkResult> final_results;

const std::map<std::string, std::string> T81_ADVANTAGES = {
    {"BM_ArithThroughput", "Exact rounding, no FP error"},
    {"BM_NegationSpeed", "Free negation (no borrow)"},
    {"BM_RoundtripAccuracy", "No sign-bit tax"},
    {"BM_OverflowDetection", "Deterministic, provable"},
    {"BM_PackingDensity_Theoretical", "Theoretical maximum"},
    {"BM_PackingDensity_Achieved", "Achieved bits/trit"},
    {"BM_PackingDensity_Practical", "Practical size ratio"}
};

class CustomReporter : public ::benchmark::BenchmarkReporter {
public:
    CustomReporter() {}
    bool ReportContext(const Context&) override { return true; }

    void ReportRuns(const std::vector<Run>& reports) override {
        for (const auto& run : reports) {
            std::string base_name = run.benchmark_name();
            base_name = base_name.substr(0, base_name.find("/"));
            bool is_t81 = base_name.find("T81Cell") != std::string::npos;

            std::string family = base_name;
            if(is_t81) family = base_name.substr(0, base_name.find("_T81Cell"));
            else family = base_name.substr(0, base_name.find("_Int64"));


            if (final_results.find(family) == final_results.end()) {
                final_results[family].name = family;
                if(T81_ADVANTAGES.count(family))
                    final_results[family].t81_advantage = T81_ADVANTAGES.at(family);
            }
            if(final_results[family].notes.empty()){
                 final_results[family].notes = run.report_label;
            }

            std::stringstream ss;
            auto items_it = run.counters.find("items_per_second");
            if (items_it != run.counters.end()) {
                double items_per_second = items_it->second;
                double gops = (items_per_second > 0) ? items_per_second / 1e9 : 0.0;
                ss << std::fixed << std::setprecision(2) << gops << " Gops/s";
                if(is_t81) final_results[family].t81_result_val = gops;
                else final_results[family].binary_result_val = gops;
            } else {
                bool first = true;
                for (auto const& [key, val] : run.counters) {
                    if (!first) ss << ", ";
                    ss << key << ": " << std::fixed << std::setprecision(2) << val;
                    first = false;
                }
            }

            if(is_t81) {
                final_results[family].t81_result_str = ss.str();
            } else {
                final_results[family].binary_result_str = ss.str();
            }
        }
    }
};

void GenerateMarkdownReport();

int main(int argc, char** argv) {
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;

    CustomReporter reporter;
    ::benchmark::RunSpecifiedBenchmarks(&reporter);
    ::benchmark::Shutdown();

    GenerateMarkdownReport();
    return 0;
}

std::string get_current_timestamp() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X UTC");
    return ss.str();
}

void GenerateMarkdownReport() {
    std::cout << "\nGenerating benchmark report...\n";

    std::cout << std::left << std::setw(25) << "Benchmark"
              << std::setw(20) << "T81 Result"
              << std::setw(20) << "Binary Result"
              << std::setw(25) << "T81 Advantage"
              << "Notes\n";
    std::cout << std::string(110, '-') << "\n";
    for(auto const& [name, r] : final_results) {
        std::cout << std::left << std::setw(25) << r.name
                  << std::setw(20) << r.t81_result_str
                  << std::setw(20) << r.binary_result_str
                  << std::setw(25) << r.t81_advantage
                  << r.notes << "\n";
    }

    std::ofstream md_file("docs/benchmarks.md");
    if (!md_file.is_open()) {
        std::cerr << "Error: Could not open docs/benchmarks.md for writing.\n";
        return;
    }

    md_file << "# TCB-Core v0.1: Official T81 Foundation Core Benchmarks\n\n";
    md_file << "This document is auto-generated by the `benchmark_runner`.\n\n";
    md_file << "*Last Updated: " << get_current_timestamp() << "*\n\n";
    md_file << "## Summary\n\n";

    md_file << "| Benchmark               | T81 Result     | Binary Result  | Ratio (T81/Binary) | T81 Advantage                   | Notes                               |\n";
    md_file << "|-------------------------|----------------|----------------|--------------------|---------------------------------|-------------------------------------|\n";

    for (auto const& [name, r] : final_results) {
        double ratio = (r.binary_result_val > 0 && r.t81_result_val > 0) ? (r.t81_result_val / r.binary_result_val) : 0.0;
        md_file << "| " << std::left << std::setw(23) << r.name
                << "| " << std::setw(14) << r.t81_result_str
                << "| " << std::setw(14) << r.binary_result_str
                << "| " << std::fixed << std::setprecision(2) << ratio << "x"
                << "| " << std::setw(31) << r.t81_advantage
                << "| " << std::setw(35) << r.notes << "|\n";
    }

    md_file << "\n## Analysis\n\n"
            << "Detailed analysis of each benchmark will be added here.\n";

    md_file.close();
    std::cout << "Successfully wrote report to docs/benchmarks.md\n";
}
