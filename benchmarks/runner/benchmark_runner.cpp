#include <benchmark/benchmark.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <algorithm>
#include <chrono>
#include <map>

// --- Custom Report Generator ---

struct BenchmarkResult {
    std::string name;
    std::string t81_result_str;
    std::string binary_result_str;
    double t81_result_val = 0.0;
    double binary_result_val = 0.0;
    std::string t81_advantage;
    std::string notes;
};

// Global store for results
std::map<std::string, BenchmarkResult> final_results;

const std::map<std::string, std::string> T81_ADVANTAGES = {
    {"BM_ArithThroughput", "Exact rounding, no FP error"},
    {"BM_NegationSpeed", "Free negation (no borrow)"},
    {"BM_RoundtripAccuracy", "No sign-bit tax"},
    {"BM_OverflowDetection", "Deterministic, provable"},
    {"BM_PackingDensity_Theoretical", "Theoretical maximum"},
    {"BM_PackingDensity_Achieved", "log2(3^N)/N"},
    {"BM_PackingDensity_Practical", "Size ratio"}
};

class CustomReporter : public ::benchmark::BenchmarkReporter {
public:
    CustomReporter() {}

    bool ReportContext(const Context& context) override {
        (void)context;
        return true;
    }

    void ReportRuns(const std::vector<Run>& reports) override {
        for (const auto& run : reports) {
            std::string name = run.benchmark_name();
            std::string base_name = name.substr(3, name.find("_", 3) - 3);
            bool is_t81 = name.find("T81Cell") != std::string::npos;

            if (final_results.find(base_name) == final_results.end()) {
                final_results[base_name].name = base_name;
                final_results[base_name].t81_advantage = T81_ADVANTAGES.at(base_name);
            }
            if(final_results[base_name].notes.empty()){
                 final_results[base_name].notes = run.report_label;
            }

            double items_per_second = (run.cpu_accumulated_time > 0) ? (run.iterations * 1e9 / run.cpu_accumulated_time) : 0.0;
            double gops = items_per_second / 1e9;
            std::stringstream ss;
            ss << std::fixed << std::setprecision(2) << gops << " Gops/s";

            if(is_t81) {
                final_results[base_name].t81_result_str = ss.str();
                final_results[base_name].t81_result_val = gops;
            } else {
                final_results[base_name].binary_result_str = ss.str();
                final_results[base_name].binary_result_val = gops;
            }
        }
    }
};


void GenerateMarkdownReport();

int main(int argc, char** argv) {
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;

    CustomReporter reporter;
    ::benchmark::RunSpecifiedBenchmarks(&reporter);
    ::benchmark::Shutdown();

    GenerateMarkdownReport();

    return 0;
}

// A simple function to get current timestamp
std::string get_current_timestamp() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X UTC");
    return ss.str();
}


void GenerateMarkdownReport() {
    std::cout << "\nGenerating benchmark report...\n";

    // --- Generate STDOUT Table ---
    std::cout << std::left << std::setw(25) << "Benchmark"
              << std::setw(15) << "T81 Result"
              << std::setw(15) << "Binary Result"
              << std::setw(25) << "T81 Advantage"
              << "Notes\n";
    std::cout << std::string(100, '-') << "\n";
    for(auto const& [name, r] : final_results) {
        std::cout << std::left << std::setw(25) << r.name
                  << std::setw(15) << r.t81_result_str
                  << std::setw(15) << r.binary_result_str
                  << std::setw(25) << r.t81_advantage
                  << r.notes << "\n";
    }

    // --- Generate Markdown File ---
    std::ofstream md_file("docs/benchmarks.md");
    if (!md_file.is_open()) {
        std::cerr << "Error: Could not open docs/benchmarks.md for writing.\n";
        return;
    }

    md_file << "# TCB-Core v0.1: Official T81 Foundation Core Benchmarks\n\n";
    md_file << "This document is auto-generated by the `benchmark_runner`.\n\n";
    md_file << "*Last Updated: " << get_current_timestamp() << "*\n\n";
    md_file << "## Summary\n\n";

    // Markdown table header
    md_file << "| Benchmark               | T81 Result     | Binary Result  | Ratio (T81/Binary) | T81 Advantage                   | Notes                               |\n";
    md_file << "|-------------------------|----------------|----------------|--------------------|---------------------------------|-------------------------------------|\n";

    // Markdown table rows
    for (auto const& [name, r] : final_results) {
        double ratio = (r.binary_result_val > 0) ? (r.t81_result_val / r.binary_result_val) : 0.0;
        md_file << "| " << std::left << std::setw(23) << r.name
                << "| " << std::setw(14) << r.t81_result_str
                << "| " << std::setw(14) << r.binary_result_str
                << "| " << std::fixed << std::setprecision(2) << std::setw(18) << std::to_string(ratio) + "x"
                << "| " << std::setw(31) << r.t81_advantage
                << "| " << std::setw(35) << r.notes << "|\n";
    }

    md_file << "\n## Analysis\n\n"
            << "Detailed analysis of each benchmark will be added here.\n";

    md_file.close();
    std::cout << "Successfully wrote report to docs/benchmarks.md\n";
}
